.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HPC::Runner::Command::submit_jobs::Utils::Scheduler::ParseInput 3"
.TH HPC::Runner::Command::submit_jobs::Utils::Scheduler::ParseInput 3 "2018-01-22" "perl v5.22.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "HPC::Runner::App::Scheduler::ParseInput"
.IX Header "HPC::Runner::App::Scheduler::ParseInput"
Parse the infile for \s-1HPC\s0 params, jobs, and batches
.SS "Subroutines"
.IX Subsection "Subroutines"
\fIparse_file_slurm\fR
.IX Subsection "parse_file_slurm"
.PP
Parse the file looking for the following conditions
.PP
lines ending in `\e`
wait
nextnode
.PP
Batch commands in groups of \f(CW$self\fR\->cpus_per_task, or smaller as wait and nextnode indicate
.PP
\fIpost_process_file_slurm\fR
.IX Subsection "post_process_file_slurm"
.PP
\fIcheck_for_commands\fR
.IX Subsection "check_for_commands"
.PP
Check all jobs to make sure they have commands
.PP
\fIprocess_lines\fR
.IX Subsection "process_lines"
.PP
Iterate through all lines in the job file
1. Sanity check \- can't use nohup or push commands to background
2. Check for \s-1HPC\s0 meta \- #HPC
3. Check for Note meta
.PP
\fIcheck_lines_add_cmd\fR
.IX Subsection "check_lines_add_cmd"
.PP
Append to the command
.PP
We check for a few cases
.PP
1. A line that is terminated by the usual newline character
.PP
.Vb 1
\&    echo "hello!"
.Ve
.PP
2. A multiline command in the usual bash sense
.PP
.Vb 2
\&    echo "goodbye!" && \e
\&        echo "not again!"
.Ve
.PP
3. The command is wait. Submit jobs we already have to the scheduler, and any jobs after 'wait', depend upon jobs before 'wait' finishing.
.PP
.Vb 1
\&    wait
.Ve
.PP
4. Deprecated! The command is 'newnode' on a line by itself. Submit all the previous jobs, but no dependenciies. Instead please use '#HPC commands_per_node' within your job file.
.PP
.Vb 3
\&    #HPC jobname=job01
\&    #HPC commands_per_node=1
\&    #HPC cpus_per_task=1
\&
\&    gzip VERY_LARGE_FILE
\&    gzip OTHER_VERY_LARGE_FILE
.Ve
.PP
\fIcheck_sanity\fR
.IX Subsection "check_sanity"
.PP
Do some sanity checks. So far we only check for nohup, because nohup confuses schedulers.
.PP
#TODO Add check for when line ends with &. This also confuses schedulers
.PP
\fIcheck_note_meta\fR
.IX Subsection "check_note_meta"
.PP
Check for lines starting with #TASK \- used to pass per process task_tags
.PP
\fIprocess_hpc_meta\fR
.IX Subsection "process_hpc_meta"
.PP
allow for changing parameters mid through the script
.PP
#Job1
echo \*(L"this is job one\*(R" && \e
    bin/dostuff bblahblahblah
.PP
#HPC cpu_per_task=12
.PP
echo \*(L"This is my new job with new \s-1HPC\s0 params!\*(R"
.PP
Make sure our hpc variables are current for filling in the template
#HPC cpus_per_task=1
to
#SBATCH \-\-cpus\-per\-task=1
