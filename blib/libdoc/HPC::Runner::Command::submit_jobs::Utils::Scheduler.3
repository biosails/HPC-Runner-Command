.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HPC::Runner::Command::submit_jobs::Utils::Scheduler 3"
.TH HPC::Runner::Command::submit_jobs::Utils::Scheduler 3 "2018-01-22" "perl v5.22.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "HPC::Runner::Command::submit_jobs::Utils::Scheduler"
.IX Header "HPC::Runner::Command::submit_jobs::Utils::Scheduler"
.SS "Command Line Options"
.IX Subsection "Command Line Options"
#TODO Move this over to docs
.PP
\fIconfig\fR
.IX Subsection "config"
.PP
Config file to pass to command line as \-\-config /path/to/file. It should be a yaml or other config supplied by Config::Any
This is optional. Paramaters can be passed straight to the command line
.PP
\fIexample.yml\fR
.IX Subsection "example.yml"
.PP
.Vb 6
\&    \-\-\-
\&    infile: "/path/to/commands/testcommand.in"
\&    outdir: "path/to/testdir"
\&    module:
\&        \- "R2"
\&        \- "shared"
.Ve
.PP
\fIinfile\fR
.IX Subsection "infile"
.PP
infile of commands separated by newline. The usual bash convention of escaping a newline is also supported.
.PP
example.in
.IX Subsection "example.in"
.PP
.Vb 9
\&    cmd1
\&    #Multiline command
\&    cmd2 \-\-input \-\-input \e
\&    \-\-someotherinput
\&    wait
\&    #Wait tells slurm to make sure previous commands have exited with exit status 0.
\&    cmd3  ##very heavy job
\&    newnode
\&    #cmd3 is a very heavy job so lets start the next job on a new node
.Ve
.PP
\fIjobname\fR
.IX Subsection "jobname"
.PP
Specify a job name, and jobs will be 001_jobname, 002_jobname, 003_jobname
.PP
Separating this out from Base \- submit_jobs and execute_job have different ways of dealing with this
.PP
\fImax_array_size\fR
.IX Subsection "max_array_size"
.PP
\fIuse_batches\fR
.IX Subsection "use_batches"
.PP
The default is to submit using job arrays.
.PP
If specified it will submit each job individually.
.PP
Example:
.PP
#HPC jobname=gzip
#HPC commands_per_node=1
gzip 1
gzip 2
gzip 3
.PP
Batches:
sbatch 001_gzip.sh
sbatch 002_gzip.sh
sbatch 003_gzip.sh
.PP
Arrays:
.PP
sbatch \-\-array=1\-3 gzip.sh
.PP
\fIafterok\fR
.IX Subsection "afterok"
.PP
The afterok switch in slurm. \-\-afterok 123 will tell slurm to start this job after job 123 has completed successfully.
.PP
\fIno_submit_to_slurm\fR
.IX Subsection "no_submit_to_slurm"
.PP
Bool value whether or not to submit to slurm. If you are looking to debug your files, or this script you will want to set this to zero.
Don't submit to slurm with \-\-no_submit_to_slurm from the command line or
\&\f(CW$self\fR\->\fIno_submit_to_slurm\fR\|(0); within your code
.PP
\&\s-1DEPRECATED \-\s0 use \-\-dry_run instead
.PP
\fIserial\fR
.IX Subsection "serial"
.PP
Option to run all jobs serially, one after the other, no parallelism
The default is to use 4 procs
.PP
\fIuse_custom\fR
.IX Subsection "use_custom"
.PP
Supply your own command instead of mcerunner/threadsrunner/etc
.SS "Internal Attributes"
.IX Subsection "Internal Attributes"
\fIscheduler_ids\fR
.IX Subsection "scheduler_ids"
.PP
Our current scheduler job dependencies
.PP
\fIjob_stats\fR
.IX Subsection "job_stats"
.PP
Object describing the number of jobs, number of batches per job, etc
.PP
\fIdeps\fR
.IX Subsection "deps"
.PP
Call as
.PP
.Vb 1
\&    #HPC deps=job01,job02
.Ve
.PP
\fIcurrent_job\fR
.IX Subsection "current_job"
.PP
Keep track of our currently running job
.PP
\fIcurrent_batch\fR
.IX Subsection "current_batch"
.PP
Keep track of our currently batch
.PP
\fItemplate\fR
.IX Subsection "template"
.PP
template object for writing slurm batch submission script
.PP
\fIcmd_counter\fR
.IX Subsection "cmd_counter"
.PP
keep track of the number of commands \- when we get to more than commands_per_node restart so we get submit to a new node.
This is the number of commands within a batch. Each new batch resets it.
.PP
\fItotal_cmd_counter\fR
.IX Subsection "total_cmd_counter"
.SS "batch_counter"
.IX Subsection "batch_counter"
Keep track of how many batches we have submited to slurm
.SS "job_counter"
.IX Subsection "job_counter"
Keep track of how many jobes we have submited to slurm
.PP
\fIbatch\fR
.IX Subsection "batch"
.PP
List of commands to submit to slurm
.PP
\fIjobs\fR
.IX Subsection "jobs"
.PP
Contains all of our info for jobs
.PP
.Vb 10
\&    {
\&        job03 => {
\&            deps => [\*(Aqjob01\*(Aq, \*(Aqjob02\*(Aq],
\&            schedulerIds => [\*(Aq123.hpc.inst.edu\*(Aq],
\&            submitted => 1/0,
\&            batch => \*(AqString of whole commands\*(Aq,
\&            cmds => [
\&                \*(Aqcmd1\*(Aq,
\&                \*(Aqcmd2\*(Aq,
\&            ]
\&        },
\&        schedule => [\*(Aqjob01\*(Aq, \*(Aqjob02\*(Aq, \*(Aqjob03\*(Aq]
\&    }
.Ve
.PP
\fIgraph_job_deps\fR
.IX Subsection "graph_job_deps"
.PP
Hashref of jobdeps to pass to Algorithm::Dependency
.PP
Job03 depends on job01 and job02
.PP
.Vb 1
\&    { \*(Aqjob03\*(Aq => [\*(Aqjob01\*(Aq, \*(Aqjob02\*(Aq] }
.Ve
.SS "Subroutines"
.IX Subsection "Subroutines"
\fIWorkflow\fR
.IX Subsection "Workflow"
.PP
There are a lot of things happening here
.PP
parse_file_slurm #we also resolve the dependency tree and write out the batch files in here
schedule_jobs
iterate_schedule
.PP
.Vb 12
\&    for $job (@scheduled_jobs)
\&        (set current_job)
\&        process_jobs
\&        if !use_batches
\&            submit_job #submit the whole job is using job arrays \- which is the default
\&        pre_process_batch
\&            (current_job, current_batch)
\&            scheduler_ids_by_batch
\&            if use_batches
\&                submit_job
\&            else
\&                run scontrol to update our jobs by job array id
.Ve
.PP
\fIrun\fR
.IX Subsection "run"
.PP
\fIcheck_jobname\fR
.IX Subsection "check_jobname"
.PP
Check to see if we the user has chosen the default jobname, 'job'
.PP
\fIcheck_add_to_jobs\fR
.IX Subsection "check_add_to_jobs"
.PP
Make sure each jobname has an entry. We set the defaults as the global configuration.
.PP
\fIincrease_jobname\fR
.IX Subsection "increase_jobname"
.PP
Increase jobname. job_001, job_002. Used for graph_job_deps
.PP
\fIcheck_files\fR
.IX Subsection "check_files"
.PP
Check to make sure the outdir exists.
If it doesn't exist the entire path will be created
.PP
\fIiterate_schedule\fR
.IX Subsection "iterate_schedule"
.PP
Iterate over the schedule generated by schedule_jobs
.PP
\fIiterate_job_deps\fR
.IX Subsection "iterate_job_deps"
.PP
Check to see if we are actually submitting
.PP
Make sure each dep has already been submitted
.PP
Return job schedulerIds
.PP
\fIprocess_jobs\fR
.IX Subsection "process_jobs"
.PP
\fIpre_process_batch\fR
.IX Subsection "pre_process_batch"
.PP
Log info for the job to the screen
.PP
\fIwork\fR
.IX Subsection "work"
.PP
Process the batch
Submit to the scheduler slurm/pbs/etc
Take care of the counters
.PP
\fIprocess_batch\fR
.IX Subsection "process_batch"
.PP
Create the slurm submission script from the slurm template
Write out template, submission job, and infile for parallel runner
.PP
\fIpost_process_batch_indexes\fR
.IX Subsection "post_process_batch_indexes"
.PP
Put the scheduler_id in each batch
.PP
\fIpost_process_jobs\fR
.IX Subsection "post_process_jobs"
